//! HRV-Adaptive Ensemble Reasoning Engine
//! Generates multiple divergent reasoning paths and selects best via embedding similarity
//! and HRV-weighted consensus

pub mod hrv_context;

pub use hrv_context::{AdaptiveParameters, HRVAdaptiveConfig, HRVContext, HRVMetrics};

use beagle_bio::{CognitiveState, HRVMonitor};
use chrono::Utc;
use ndarray::Array1;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tracing::info;

// ============================================================================
// Reasoning Path Types
// ============================================================================

/// Single reasoning path generated by LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReasoningPath {
    pub id: String,
    pub content: String,
    pub temperature_used: f64,
    pub max_tokens_used: u32,
    pub generated_at: chrono::DateTime<chrono::Utc>,
    pub confidence: Option<f64>,
}

/// Embedding vector for a reasoning path (normalized)
#[derive(Debug, Clone)]
pub struct EmbeddingVector {
    pub path_id: String,
    pub embedding: Array1<f64>,
}

/// Consensus result from ensemble
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnsembleConsensus {
    pub best_path: ReasoningPath,
    pub all_paths: Vec<ReasoningPath>,
    pub confidence_scores: HashMap<String, f64>,
    pub cognitive_state: String,
    pub consensus_score: f64,
    pub generated_at: chrono::DateTime<chrono::Utc>,
}

// ============================================================================
// Embedding & Similarity Functions
// ============================================================================

/// Compute cosine similarity between two embedding vectors
fn cosine_similarity(a: &Array1<f64>, b: &Array1<f64>) -> f64 {
    let dot_product: f64 = a.iter().zip(b.iter()).map(|(x, y)| x * y).sum();
    let norm_a: f64 = a.iter().map(|x| x * x).sum::<f64>().sqrt();
    let norm_b: f64 = b.iter().map(|x| x * x).sum::<f64>().sqrt();

    if norm_a == 0.0 || norm_b == 0.0 {
        return 0.0;
    }
    dot_product / (norm_a * norm_b)
}

/// Generate mock embedding for a text (deterministic for testing)
/// In production, would use actual embedding model
fn generate_embedding(text: &str, dimension: usize) -> Array1<f64> {
    let hash = text.bytes().fold(0u64, |acc, b| acc.wrapping_mul(31).wrapping_add(b as u64));
    let mut embedding = Array1::zeros(dimension);

    for i in 0..dimension {
        let seed = hash.wrapping_mul((i as u64).wrapping_add(1));
        embedding[i] = ((seed as f64) % 2.0 - 1.0) / (dimension as f64).sqrt();
    }

    // Normalize
    let norm: f64 = embedding.iter().map(|x| x * x).sum::<f64>().sqrt();
    embedding / (norm.max(1e-8))
}

// ============================================================================
// Ensemble Reasoning Engine
// ============================================================================

/// Generates and combines multiple reasoning paths based on HRV state
pub struct EnsembleReasoningEngine {
    hrv_monitor: Arc<HRVMonitor>,
    embedding_dim: usize,
    #[allow(dead_code)]
    max_paths: usize,
}

impl EnsembleReasoningEngine {
    /// Create new ensemble engine
    pub fn new(hrv_monitor: Arc<HRVMonitor>) -> Self {
        Self {
            hrv_monitor,
            embedding_dim: 384,  // Standard embedding dimension
            max_paths: 5,
        }
    }

    /// Consensus reasoning with HRV-aware weighting
    pub async fn consensus_reasoning(
        &self,
        _prompt: &str,
        paths: Vec<ReasoningPath>,
    ) -> anyhow::Result<EnsembleConsensus> {
        // Get current cognitive state
        let cognitive_state = self.hrv_monitor.current_state().await;
        let intensity = cognitive_state.reasoning_intensity();

        // Generate embeddings for each path
        let embeddings: Vec<EmbeddingVector> = paths
            .iter()
            .map(|p| EmbeddingVector {
                path_id: p.id.clone(),
                embedding: generate_embedding(&p.content, self.embedding_dim),
            })
            .collect();

        // Calculate consensus scores using embedding similarity
        let mut scores: HashMap<String, f64> = HashMap::new();
        let mut total_score = 0.0;

        for emb in &embeddings {
            let mut similarity_sum = 0.0;
            let mut count = 0;

            for other_emb in &embeddings {
                if emb.path_id != other_emb.path_id {
                    let sim = cosine_similarity(&emb.embedding, &other_emb.embedding);
                    similarity_sum += sim.max(0.0);
                    count += 1;
                }
            }

            let avg_similarity = if count > 0 {
                similarity_sum / count as f64
            } else {
                0.5
            };

            // Weight by cognitive state intensity
            let weighted_score = avg_similarity * (0.5 + 0.5 * intensity);
            scores.insert(emb.path_id.clone(), weighted_score);
            total_score += weighted_score;
        }

        // Normalize scores
        if total_score > 0.0 {
            for score in scores.values_mut() {
                *score /= total_score;
            }
        }

        // Select best path
        let best_path = paths
            .iter()
            .max_by(|a, b| {
                scores
                    .get(&a.id)
                    .unwrap_or(&0.0)
                    .partial_cmp(scores.get(&b.id).unwrap_or(&0.0))
                    .unwrap_or(std::cmp::Ordering::Equal)
            })
            .cloned()
            .ok_or_else(|| anyhow::anyhow!("No paths provided"))?;

        let consensus_score = scores.get(&best_path.id).copied().unwrap_or(0.0);

        info!(
            "Ensemble consensus: {} with state {} (score: {:.3})",
            best_path.id,
            cognitive_state.description(),
            consensus_score
        );

        Ok(EnsembleConsensus {
            best_path,
            all_paths: paths,
            confidence_scores: scores,
            cognitive_state: format!("{:?}", cognitive_state),
            consensus_score,
            generated_at: Utc::now(),
        })
    }

    /// Determine if ensemble reasoning should be used
    pub async fn should_use_ensemble(&self) -> bool {
        let state = self.hrv_monitor.current_state().await;
        state == CognitiveState::PeakFlow
    }

    /// Get number of paths to generate based on HRV
    pub async fn get_num_paths(&self) -> usize {
        let state = self.hrv_monitor.current_state().await;
        state.num_reasoning_paths()
    }

    /// Get adaptive temperature for LLM
    pub async fn get_adaptive_temperature(&self, base_temp: f64) -> f64 {
        let state = self.hrv_monitor.current_state().await;
        state.temperature_multiplier() * base_temp
    }
}

impl Default for EnsembleReasoningEngine {
    fn default() -> Self {
        let monitor = Arc::new(HRVMonitor::with_mock());
        Self::new(monitor)
    }
}

// ============================================================================
// Adaptive Routing
// ============================================================================

/// Gates and routes requests based on HRV state
pub struct AdaptiveRouter {
    hrv_monitor: Arc<HRVMonitor>,
    ensemble_engine: Arc<EnsembleReasoningEngine>,
}

impl AdaptiveRouter {
    pub fn new(hrv_monitor: Arc<HRVMonitor>, ensemble_engine: Arc<EnsembleReasoningEngine>) -> Self {
        Self {
            hrv_monitor,
            ensemble_engine,
        }
    }

    /// Determine routing strategy based on HRV state
    pub async fn get_routing_strategy(&self) -> RoutingStrategy {
        let state = self.hrv_monitor.current_state().await;
        let _sdnn = self.hrv_monitor.average_sdnn().await;

        match state {
            CognitiveState::PeakFlow => RoutingStrategy {
                use_ensemble: true,
                num_paths: 5,
                temperature_mult: 1.0,
                max_tokens_mult: 1.0,
                priority: "high".to_string(),
            },
            CognitiveState::Nominal => RoutingStrategy {
                use_ensemble: false,
                num_paths: 3,
                temperature_mult: 0.8,
                max_tokens_mult: 0.8,
                priority: "normal".to_string(),
            },
            CognitiveState::Stressed => RoutingStrategy {
                use_ensemble: false,
                num_paths: 1,
                temperature_mult: 0.5,
                max_tokens_mult: 0.5,
                priority: "low".to_string(),
            },
        }
    }

    /// Check if complex reasoning should be gated
    pub async fn can_perform_complex_reasoning(&self) -> bool {
        self.ensemble_engine.should_use_ensemble().await
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RoutingStrategy {
    pub use_ensemble: bool,
    pub num_paths: usize,
    pub temperature_mult: f64,
    pub max_tokens_mult: f64,
    pub priority: String,
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cosine_similarity() {
        let v1 = Array1::from_vec(vec![1.0, 0.0, 0.0]);
        let v2 = Array1::from_vec(vec![1.0, 0.0, 0.0]);
        assert!((cosine_similarity(&v1, &v2) - 1.0).abs() < 0.01);

        let v3 = Array1::from_vec(vec![0.0, 1.0, 0.0]);
        assert!((cosine_similarity(&v1, &v3) - 0.0).abs() < 0.01);
    }

    #[test]
    fn test_generate_embedding() {
        let emb = generate_embedding("test", 384);
        assert_eq!(emb.len(), 384);

        // Check normalization
        let norm: f64 = emb.iter().map(|x| x * x).sum::<f64>().sqrt();
        assert!((norm - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_embedding_determinism() {
        let emb1 = generate_embedding("hello", 384);
        let emb2 = generate_embedding("hello", 384);
        assert!(emb1.iter().zip(emb2.iter()).all(|(a, b)| (a - b).abs() < 1e-10));
    }

    #[tokio::test]
    async fn test_ensemble_engine_creation() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = EnsembleReasoningEngine::new(monitor);
        assert_eq!(engine.embedding_dim, 384);
        assert_eq!(engine.max_paths, 5);
    }

    #[tokio::test]
    async fn test_should_use_ensemble() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = EnsembleReasoningEngine::new(monitor);
        let should_use = engine.should_use_ensemble().await;
        assert!(matches!(should_use, true | false));
    }

    #[tokio::test]
    async fn test_get_num_paths() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = EnsembleReasoningEngine::new(monitor);
        let num_paths = engine.get_num_paths().await;
        assert!(num_paths >= 1 && num_paths <= 5);
    }

    #[tokio::test]
    async fn test_get_adaptive_temperature() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = EnsembleReasoningEngine::new(monitor);
        let temp = engine.get_adaptive_temperature(1.0).await;
        assert!(temp >= 0.5 && temp <= 1.0);
    }

    #[tokio::test]
    async fn test_consensus_reasoning() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = EnsembleReasoningEngine::new(monitor);

        let paths = vec![
            ReasoningPath {
                id: "path1".to_string(),
                content: "First reasoning path about quantum mechanics".to_string(),
                temperature_used: 0.7,
                max_tokens_used: 256,
                generated_at: Utc::now(),
                confidence: Some(0.8),
            },
            ReasoningPath {
                id: "path2".to_string(),
                content: "Second reasoning path about quantum mechanics".to_string(),
                temperature_used: 0.7,
                max_tokens_used: 256,
                generated_at: Utc::now(),
                confidence: Some(0.7),
            },
        ];

        let result = engine
            .consensus_reasoning("What is quantum entanglement?", paths)
            .await;
        assert!(result.is_ok());

        let consensus = result.unwrap();
        assert!(!consensus.all_paths.is_empty());
        assert!(consensus.consensus_score >= 0.0 && consensus.consensus_score <= 1.0);
    }

    #[tokio::test]
    async fn test_adaptive_router_creation() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = Arc::new(EnsembleReasoningEngine::new(Arc::clone(&monitor)));
        let router = AdaptiveRouter::new(monitor, engine);

        let strategy = router.get_routing_strategy().await;
        assert!(!strategy.priority.is_empty());
        assert!(strategy.temperature_mult >= 0.5 && strategy.temperature_mult <= 1.0);
    }

    #[tokio::test]
    async fn test_adaptive_router_can_perform_complex() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = Arc::new(EnsembleReasoningEngine::new(Arc::clone(&monitor)));
        let router = AdaptiveRouter::new(monitor, engine);

        let can_complex = router.can_perform_complex_reasoning().await;
        assert!(matches!(can_complex, true | false));
    }

    #[tokio::test]
    async fn test_routing_strategy_components() {
        let monitor = Arc::new(HRVMonitor::with_mock());
        let engine = Arc::new(EnsembleReasoningEngine::new(Arc::clone(&monitor)));
        let router = AdaptiveRouter::new(monitor, engine);

        let strategy = router.get_routing_strategy().await;
        assert!(strategy.num_paths >= 1 && strategy.num_paths <= 5);
        assert!(strategy.temperature_mult > 0.0);
        assert!(strategy.max_tokens_mult > 0.0);
    }
}
