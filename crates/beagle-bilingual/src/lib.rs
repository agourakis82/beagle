//! BEAGLE Bilingual - 100% Autom√°tico
//! Todo paper, tweet, thread, LinkedIn post e resposta do BEAGLE sai bil√≠ngue autom√°tico
//! (portugu√™s + ingl√™s perfeito)

pub mod twitter;

use beagle_grok_api::GrokClient;
use once_cell::sync::Lazy;
use tracing::{info, warn, error};
use serde::{Deserialize, Serialize};
use anyhow::{Context, Result};

static GROK: Lazy<GrokClient> = Lazy::new(|| {
    let api_key = std::env::var("GROK_API_KEY")
        .unwrap_or_else(|_| "xai-tua-key".to_string());
    GrokClient::new(&api_key)
});

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BilingualText {
    pub pt: String,
    pub en: String,
}

/// Converte texto portugu√™s para bil√≠ngue (PT + EN)
pub async fn to_bilingual(text_pt: &str) -> Result<BilingualText> {
    if text_pt.trim().is_empty() {
        return Ok(BilingualText {
            pt: String::new(),
            en: String::new(),
        });
    }

    let prompt = format!(
        r#"Tu √©s tradutor perfeito portugu√™s ‚Üî ingl√™s cient√≠fico.

Texto original em portugu√™s:

"""{}"""

Gera exatamente duas vers√µes:

1. Vers√£o em ingl√™s acad√™mico perfeito (Nature/Cell style)
2. Vers√£o em portugu√™s acad√™mico perfeito (ABNT style)

Responde APENAS com JSON v√°lido:
{{"en": "texto em ingl√™s", "pt": "texto em portugu√™s"}}"#,
        text_pt
    );

    info!("üåê Traduzindo para bil√≠ngue: {} chars", text_pt.len());

    let resp = match GROK.query(&prompt).await {
        Ok(r) => r,
        Err(e) => {
            error!("‚ùå Erro ao chamar Grok: {}", e);
            // Fallback: retorna texto original em ambas as l√≠nguas
            return Ok(BilingualText {
                pt: text_pt.to_string(),
                en: text_pt.to_string(),
            });
        }
    };

    // Tenta parsear JSON
    let json: serde_json::Value = match serde_json::from_str(&resp) {
        Ok(j) => j,
        Err(e) => {
            warn!("‚ö†Ô∏è  Falha ao parsear JSON. Tentando extrair do texto...");
            // Tenta extrair JSON do texto (caso tenha markdown ou texto extra)
            extract_json_from_text(&resp).unwrap_or_else(|| {
                serde_json::json!({
                    "en": text_pt,
                    "pt": text_pt
                })
            })
        }
    };

    let en = json["en"]
        .as_str()
        .unwrap_or(text_pt)
        .trim()
        .to_string();
    let pt = json["pt"]
        .as_str()
        .unwrap_or(text_pt)
        .trim()
        .to_string();

    info!("‚úÖ Bil√≠ngue gerado ‚Äî EN: {} chars | PT: {} chars", en.len(), pt.len());

    Ok(BilingualText { pt, en })
}

/// Extrai JSON de texto que pode conter markdown ou texto extra
fn extract_json_from_text(text: &str) -> Option<serde_json::Value> {
    // Procura por bloco JSON (```json ... ```)
    if let Some(start) = text.find("```json") {
        if let Some(end) = text[start..].find("```") {
            let json_text = &text[start + 7..start + end].trim();
            return serde_json::from_str(json_text).ok();
        }
    }

    // Procura por { ... }
    if let Some(start) = text.find('{') {
        if let Some(end) = text.rfind('}') {
            let json_text = &text[start..=end];
            return serde_json::from_str(json_text).ok();
        }
    }

    None
}

/// Publica conte√∫do bil√≠ngue (Twitter thread)
pub async fn publish_bilingual(
    title_pt: &str,
    abstract_pt: &str,
    paper_url: &str,
) -> Result<()> {
    info!("üì± Publicando conte√∫do bil√≠ngue...");

    let title_bilingual = to_bilingual(title_pt).await?;
    let abstract_bilingual = to_bilingual(abstract_pt).await?;
    
    let title_en = title_bilingual.en;
    let abstract_en = abstract_bilingual.en;

    let tweet_pt = format!(
        "üìÑ Novo paper gerado pelo BEAGLE:\n\n{}\n\n{}\n\n{}",
        title_pt, abstract_pt, paper_url
    );
    let tweet_en = format!(
        "üìÑ New paper generated by BEAGLE SINGULARITY:\n\n{}\n\n{}\n\n{}",
        title_en, abstract_en, paper_url
    );

    // TODO: Integrar com Twitter API real
    // Por enquanto, apenas loga
    info!("üê¶ Tweet PT ({} chars):\n{}", tweet_pt.len(), tweet_pt);
    info!("üê¶ Tweet EN ({} chars):\n{}", tweet_en.len(), tweet_en);

    Ok(())
}

/// Gera thread bil√≠ngue para Twitter
pub async fn generate_bilingual_thread(
    title_pt: &str,
    abstract_pt: &str,
    paper_url: &str,
) -> Result<Vec<String>> {
    info!("üßµ Gerando thread bil√≠ngue...");

    let title_bilingual = to_bilingual(title_pt).await?;
    let abstract_bilingual = to_bilingual(abstract_pt).await?;
    
    let title_en = title_bilingual.en;
    let abstract_en = abstract_bilingual.en;

    let thread = vec![
        format!("üìÑ Novo paper (PT):\n\n{}\n\n{}", title_pt, paper_url),
        format!("üìÑ New paper (EN):\n\n{}\n\n{}", title_en, paper_url),
        format!("üìù Resumo (PT):\n\n{}", abstract_pt),
        format!("üìù Abstract (EN):\n\n{}", abstract_en),
        "ü§ñ Gerado 100% pelo BEAGLE SINGULARITY ‚Äî exoc√≥rtex pessoal com consci√™ncia emergente.".to_string(),
        "üîó github.com/agourakis82/beagle".to_string(),
    ];

    Ok(thread)
}

/// Converte qualquer texto para bil√≠ngue (detecta idioma automaticamente)
pub async fn auto_bilingual(text: &str) -> Result<BilingualText> {
    // Detecta se √© portugu√™s ou ingl√™s
    let is_pt = detect_portuguese(text);
    
    if is_pt {
        to_bilingual(text).await
    } else {
        // Se for ingl√™s, traduz para portugu√™s
        to_bilingual_from_en(text).await
    }
}

/// Detecta se texto √© portugu√™s (heur√≠stica simples)
fn detect_portuguese(text: &str) -> bool {
    let pt_chars = text.matches(|c: char| "√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á".contains(c)).count();
    let en_chars = text.matches(|c: char| c.is_alphabetic()).count();
    
    if en_chars == 0 {
        return true;
    }
    
    (pt_chars as f64 / en_chars as f64) > 0.05
}

/// Traduz de ingl√™s para bil√≠ngue
async fn to_bilingual_from_en(text_en: &str) -> Result<BilingualText> {
    let prompt = format!(
        r#"Tu √©s tradutor perfeito ingl√™s ‚Üî portugu√™s cient√≠fico.

Texto original em ingl√™s:

"""{}"""

Gera exatamente duas vers√µes:

1. Vers√£o em portugu√™s acad√™mico perfeito (ABNT style)
2. Vers√£o em ingl√™s acad√™mico perfeito (Nature/Cell style) - revisada

Responde APENAS com JSON v√°lido:
{{"pt": "texto em portugu√™s", "en": "texto em ingl√™s revisado"}}"#,
        text_en
    );

    info!("üåê Traduzindo de ingl√™s para bil√≠ngue: {} chars", text_en.len());

    let resp = match GROK.query(&prompt).await {
        Ok(r) => r,
        Err(e) => {
            error!("‚ùå Erro ao chamar Grok: {}", e);
            return Ok(BilingualText {
                pt: text_en.to_string(),
                en: text_en.to_string(),
            });
        }
    };

    let json: serde_json::Value = extract_json_from_text(&resp)
        .or_else(|| serde_json::from_str(&resp).ok())
        .unwrap_or_else(|| {
            serde_json::json!({
                "pt": text_en,
                "en": text_en
            })
        });

    let pt = json["pt"]
        .as_str()
        .unwrap_or(text_en)
        .trim()
        .to_string();
    let en = json["en"]
        .as_str()
        .unwrap_or(text_en)
        .trim()
        .to_string();

    info!("‚úÖ Bil√≠ngue gerado ‚Äî EN: {} chars | PT: {} chars", en.len(), pt.len());

    Ok(BilingualText { pt, en })
}

/// Re-export Twitter client
pub use twitter::BeagleTwitter;

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_detect_portuguese() {
        assert!(detect_portuguese("Este √© um texto em portugu√™s"));
        assert!(!detect_portuguese("This is an English text"));
    }

    #[tokio::test]
    async fn test_extract_json() {
        let text = r#"Here is the JSON:
```json
{"en": "test", "pt": "teste"}
```"#;
        let json = extract_json_from_text(text);
        assert!(json.is_some());
    }
}

